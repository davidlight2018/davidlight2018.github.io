<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自相关图和白噪声</title>
      <link href="/2020/04/12/time-series-intro/"/>
      <url>/2020/04/12/time-series-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="时间序列模式">时间序列模式</h2><h3 id="几种模式">几种模式</h3><ol type="1"><li><p>趋势</p><p>当一个时间序列数据长期增长或长期下降时，表示该序列有 <em>趋势</em>。</p></li><li><p>季节性</p><p>当时间序列中的数据收到季节性因素（一年或一周的时间）的影响时，表示该序列具有 <em>季节性</em>。季节性总是一个已知并且固定的频率。</p></li><li><p>周期性</p><p>当时间序列数据存在不固定频率的上升和下降时，表示该序列具有 <em>周期性</em>。</p></li></ol><h4 id="季节性-vs-周期性">季节性 vs 周期性</h4><p>当数据的波动是无规律时，表示序列存在周期性；如果波动的频率不变而且与固定长度的时间段有关，表示序列存在季节性。一般而言，周期的长度较长，并且周期的波动幅度也更大。</p><h4 id="示例">示例</h4><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/2020-04-10_17-59-35.png" style="zoom:33%;" /></p><ul><li><p>美国新建房屋销售额（左上）</p><p>表现出强烈的年度季节性，以及周期为 6-10 年的周期性。但是数据并没有表现出明显的趋势。</p></li><li><p>美国国债价格（右上）</p><p>该序列并没有季节性，但是有明显下降的趋势。</p></li><li><p>澳大利亚季度电力产值（左下）</p><p>表现出向上增长的趋势，以及强季节性。但是并不存在周期性。</p></li><li><p>Google收盘股价格（右下）</p><p>该价格波动没有趋势，也没有季节性和周期性。随机波动没有良好的形态特征，不能很好地预测。</p></li></ul><h2 id="相关图">相关图</h2><p>我们在 <a href="/2020/04/11/statistic-intro/">统计学中的一些概念</a> 中提到了自相关系数，通过将自相关系数 <span class="math inline">\(r_k\)</span> 绘制成图，即可得到自相关函数（Autocorrelation），也称作相关图（ACF）。</p><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/aelec-1.png" style="zoom:80%;"   ></p><p>上图表示 1980-1995 年间澳大利亚月度用电量，可以看出该图具有向上的趋势，以及明显的季节性。下图则是其对应的 ACF 图。</p><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/acfelec-1.png" style="zoom:80%;" ></p><p>当数据具有趋势性时，短期滞后的自相关值较大，因为观测点附近的值波动不会很大（也就是说，离观测点近的数据点会和观测点的数值相近）。这时候的时间序列的 ACF 一般是正值，随着滞后阶数的增加而缓慢下降。</p><p>当数据具有季节性时，自相关值在滞后阶数与季节周期相同（或其倍数）时较大。可以看到图中，每年会有一个高峰和低估，因此在滞后阶数为 12 的倍数时，其自相关值会呈现「圆齿状」。</p><h2 id="白噪声">白噪声</h2><p>白噪声是一个对所有时间，其自相关系数为零的随机过程。</p><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/wnoise-1.png" style="zoom: 80%;" ></p><p><img src="https://otexts.com/fppcn/fpp_files/figure-html/wnoiseacf-1.png" style="zoom:80%;" ></p><p>对于白噪声而言，我们期望它的自相关值接近零。但是由于随机扰动的存在，自相关值并不会精确地等于零。对于一个长度为 <span class="math inline">\(T\)</span> 的白噪声序列而言，我们期望在 0.95 的置信度下，它的自相关值处于 <span class="math inline">\(\frac{2}{\sqrt{T}}\)</span> 之间。我们可以很容易的画出 ACF 的边界值（图中蓝色虚线）。如果一个序列中有较多自相关值处于边界之外，那么该序列很可能不是白噪声序列。</p><p>在上例中，序列长度 <span class="math inline">\(T=50\)</span>，因此边界为 <span class="math inline">\(\frac{2}{\sqrt{50}}=0.28\)</span>。该序列所有的自相关值都落在边界之内，因此该序列为白噪声。</p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> 时间序列 </tag>
            
            <tag> 自相关图 </tag>
            
            <tag> 白噪声 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差和相关系数</title>
      <link href="/2020/04/11/statistic-intro/"/>
      <url>/2020/04/11/statistic-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="期望值">期望值</h2><p>在概率论和统计学中，一个离散性随机变量的期望值，是试验中每次可能的结果乘以其概率结果的总和。而在实际的应用或案例中，我们通常遇到的情况都是离散的。因此这里只简单介绍一下此种情况的期望值如何计算。</p><h3 id="定义">定义</h3><p>若 <span class="math inline">\(X\)</span> 是离散的随机变量，输出值为 <span class="math inline">\(x_1, x_2, \cdots\)</span>，与输出值相应的概率为 <span class="math inline">\(p_1, p_2, \cdots\)</span>（概率和为1），则 <span class="math inline">\(X\)</span> 的期望值如下： <span class="math display">\[E(X) = \sum_i{p_ix_i}\]</span> 当样本发生概率都相同时（平均分布），期望值又等于均值 <span class="math inline">\(E(X) = \bar{x}\)</span>。</p><h3 id="性质">性质</h3><ul><li><p>期望值是线性函数</p><p><span class="math inline">\(E(aX+bY)=aE(X)+bE(Y)\)</span></p></li><li><p>当随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的协方差为 0 时（又称它们不相关），下面等式成立。（特别地，当 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 独立时，协方差也为 0）</p><p><span class="math inline">\(E(XY)=E(X) \cdot E(Y)\)</span></p></li></ul><h2 id="协方差">协方差</h2><p>协方差（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。通俗来说，就是两个变量在变化过程中的变化趋势，是同方向变化还是反方向变化？同向或反向程度如何？</p><p>若两个变量是同向变化的，这时协方差就是正的；若两个变量反向变化，这时协方差就是负的。协方差数值越大，表示两个变量的同向程度也越大。</p><h3 id="定义-1">定义</h3><p>若随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的期望值分别是 <span class="math inline">\(E(X)=\mu, E(Y)=\nu\)</span>，则 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 之间的协方差为： <span class="math display">\[Cov(X, Y) = E[(X-\mu)(Y-\nu)] = E(XY) - \mu\nu\]</span> 该公式简单来说就是，两个变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的协方差为，「每个时刻的 <span class="math inline">\(X\)</span> 与其期望之差」乘以「对应时刻的 <span class="math inline">\(Y\)</span> 与其期望之差」，最后再对得到的乘积求和并计算其期望值。</p><p>若 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是统计独立的，那么二者的协方差为 0，这是因为 <span class="math display">\[E(XY) = E(X) \cdot E(Y) = \mu\nu\]</span> 但是反过来并不成立，即若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的协方差为 0，二者并不一定是统计独立的，但是二者之间一定是不相关的。</p><p>另外，对于 N 个相等概率值的平均分布， <span class="math display">\[Cov(X, Y) = \frac{1}{N} \sum_i^N (x_i-\bar{x})(y_i-\bar{y})\]</span></p><h2 id="方差">方差</h2><p>方差（Variance）是协方差的特殊情况，即两个变量是相同的。在概率论和统计学中，一个随机变量的方差描述的是它的离散程度，也就是该变量与其期望值的距离。方差越大，代表大部分数值与其期望之间的差异较大。</p><h3 id="定义-2">定义</h3><p>若随机变量 <span class="math inline">\(X\)</span> 的期望值 <span class="math inline">\(E(X)=\mu\)</span>，则 <span class="math inline">\(X\)</span> 的方差为： <span class="math display">\[\begin{aligned}Var(X) &amp;= E[(X-\mu)^2] = Cov(X, X)\end{aligned}\]</span> 将上式展开可得： <span class="math display">\[Var(X) = E[X^2-2X \cdot E(X)+[E(X)]^2]=E(X^2)-2E(X) \cdot E(X) + [E(X)]^2 = E(X^2)-[E(X)]^2\]</span> 即 <span class="math inline">\(X\)</span> 的方差为「其平方的期望」减去「其期望的平方」。</p><p>若 <span class="math inline">\(X\)</span> 是离散的随机变量，输出值为 <span class="math inline">\(x_1, x_2, \cdots\)</span>，与输出值相应的概率为 <span class="math inline">\(p_1, p_2, \cdots\)</span>（概率和为1），则 <span class="math inline">\(X\)</span> 的方差如下： <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_i{p_ix_i} = \mu\\Var(X) &amp;= \sum_i p_i \cdot (x_i-\mu)^2 = \sum_i(p_i \cdot {x_i}^2) - \mu^2\end{aligned}\]</span> 而对于 N 个相等概率值的平均分布， <span class="math display">\[Var(X) = \sigma^2 = \frac{1}{N} \sum_i^N(x_i-\bar{x})^2 = \frac{1}{N}\sum_i^N{x_i}^2 - {\bar{x}}^2\]</span></p><h3 id="标准差">标准差</h3><p>我们通常用 <span class="math inline">\(\sigma^2\)</span> 来表示方差，而 <span class="math inline">\(\sigma\)</span> 则表示标准差（Standard Deviation）。</p><p>标准差与方差一样用来表示组内数据间的离散程度，但是相比于方差，标准差用来表示离散程度的数字与样本数据点的数量级和单位一致，更容易理解和后续的分析计算。</p><p>另外，在样本数据大致符合正态分布的情况下，标准差具有方便估算的特性：68.3% 的数据点落在平均值前后 1 个标准差的范围内；95.4% 的数据点落在平均值前后 2 个标准差的范围内；而 99.7% 的数据点将会落在平均值前后 3 个标准差的范围内。因此可以使用 <span class="math inline">\(3\sigma\)</span> 定律排除掉异常的数据点。</p><h2 id="相关系数">相关系数</h2><h3 id="定义-3">定义</h3><p>两个变量之间的皮尔逊相关系数（Pearson Correlation Coeffocient）定义为两个变量之间的协方差和标准差的商，用于度量变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 之间的线性相关关系，取值范围为 [-1, 1]，其中正数表示正线性相关，负数表示负线性相关，而 0 表示非线性相关。 <span class="math display">\[\rho_{X, Y} = \frac{Cov(X, Y)}{\sigma_X \sigma_Y}\]</span> 因此，相关系数也可以看作成一种协方差：一种剔除了两个变量的量纲影响、标准化后的特殊协方差。它消除了两个变量间变化幅度的影响，更能反应出两个变量每单位变化时的相似程度。</p><p>而对于样本的相关系数，常用 <span class="math inline">\(r\)</span> 来表示： <span class="math display">\[r = \frac{\sum_{i=1}^N (x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\sum_{i=1}^N(x_i-\bar{x})^2}\sqrt{\sum_{i=1}^N(y_i-\bar{y})^2}}\]</span> 下图是几组 (x, y) 的点集，以及各个点集中 x 和 y 之间的相关系数。我们可以发现相关系数反映的是变量之间的线性关系和相关性的方向（第一排），而不是相关性的斜率（中间），也不是各种非线性关系（第三排）。请注意：中间的图中斜率为 0，但相关系数是没有意义的，因为此时变量 Y 是 0。</p><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/2020-04-12_20-40-17.png" style="zoom:20%;" /></p><center style="font-size:16px;color:#808080;text-decoration:underline">图1. 来自维基百科</center><h2 id="自相关系数">自相关系数</h2><p>正如相关系数可以衡量两个变量之间的线性相关关系一样，自相关系数（Autocorrelation）可以测量时间序列 <strong>滞后值</strong> 之间的线性关系。</p><h3 id="定义-4">定义</h3><p>我们用 <span class="math inline">\(r_k\)</span> 来表示自相关系数，例如 <span class="math inline">\(r_1\)</span> 衡量的是 <span class="math inline">\(y_t\)</span> 和 <span class="math inline">\(y_{t-1}\)</span> 之间的关系， <span class="math inline">\(r_2\)</span> 衡量的是 <span class="math inline">\(y_t\)</span> 和 <span class="math inline">\(y_{t-2}\)</span> 之间的关系。其中 <span class="math inline">\(T\)</span> 是时间序列的长度 <span class="math display">\[r_k = \frac{\sum_{t=k+1}^T (y_t-\bar{y})(y_{t-k}-\bar{y})}{\sqrt{\sum_{t=1}^T(y_t-\bar{y})^2}}\]</span></p><p>自相关系数值越高，代表这两个时间点具有更高的线性相关性。</p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 期望值 </tag>
            
            <tag> 协方差 </tag>
            
            <tag> 方差 </tag>
            
            <tag> 相关系数 </tag>
            
            <tag> 自相关系数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『阅读笔记』 iDice - Problem Identiﬁcation for Emerging Issues</title>
      <link href="/2020/04/02/idice-intro/"/>
      <url>/2020/04/02/idice-intro/</url>
      
        <content type="html"><![CDATA[<p>这篇 paper 由微软团队在 2016 年发表<sup id="a1"><a href="#f1">1</a></sup>。在这篇文章中，他们提出了结合了多种剪枝策略的封闭项挖掘算法，主要用于解决异常报告（emerging issues）的根因定位与根因分析等问题。</p><h2 id="背景介绍">背景介绍</h2><h3 id="问题描述和挑战">问题描述和挑战</h3><p>多维度指标的异常定位是 AIOps 领域的一个典型且有挑战的问题。在互联网服务运维中，当某个总指标（如总流；量）发生异常时，需要快速准确地定位到是哪个交叉维度的细粒度指标（如“省份=北京 &amp; 运营商=联通”的流量）的异常导致的，以便尽快做进一步的修复止损动作。由于运维中的指标维度多、每个维度的取值范围大，导致异常定位的搜索空间非常大。同时，由于这些属性通常都包括时间戳，因此诸如“挖掘频繁子集”的方法在此场景下就不太适用。</p><h3 id="有效组合">有效组合</h3><p>我们将出现问题的属性组合称为有效组合（effective combinations），因此面临的挑战是从所有可能的组合中自动且精准地识别出有效组合。整个属性组合通过子集-超集的关系形成一种格结构。每个节点表示一个属性组合，每条边表示一个子集-超集关系。</p><p>对于 X 和 Y 的两个属性组合，如果包含 X 的数据也包含在 Y 的数据中，则称 X 为 Y 的子集，Y 为 X 的超集。例如，{A, B, C} 是 {A, B} 和 {A, C} 的子集。</p><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/2020-04-03_15-40-37.png" style="zoom: 50%;" /></p><center style="font-size:16px;color:#808080;text-decoration:underline">图1. 有效组合</center><h3 id="需要达到的要求">需要达到的要求</h3><ol type="1"><li>实时性要求高。当维度较多而且各维度中属性值数目较多时，考验算法的计算效率。</li><li>元素指标之间的关系复杂。例如，当维度为位置，属性值为“北京”的 KPI 发生异常时，一般属性值为“北京移动”、“北京联通”的 KPI 也会发生异常，进而属性值为“移动”、“联通”的 KPI 也会发生异常。</li><li>结果尽可能简洁。用尽可能少的维度及其属性值的组合来表示最为全面的根因。</li></ol><h2 id="idice-算法介绍">iDice 算法介绍</h2><p>iDice 使用三种剪枝策略来减少巨大的搜索空间，分别为基于影响程度的剪枝（Impact based Pruning）、基于变化检测的剪枝（Change Detection based Pruning）和基于隔离能力的剪枝（Isolation Power based Pruning）。</p><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/2020-04-03_18-05-13.png" style="zoom:40%;" /></p><center style="font-size:16px;color:#808080;text-decoration:underline">图2. iDice 执行流程</center><h3 id="基于影响程度的剪枝">基于影响程度的剪枝</h3><p>我们仅考虑与大量问题报告相关联的属性集，而将那些问题报告不足的属性集剪掉。</p><p>用户可以通过自定义支持阈值（support threshold）<sup id="a2"><a href="#f2">2</a></sup> 来决定保留哪些属性集合。</p><p>iDice 使用基于 BFS 的封闭项集挖掘算法，在这种情况会忽略问题报告的时间戳信息。</p><p>假设我们有两组属性组合：</p><p>X = {Country=India; TenantType=Edu; DataCenter=DC6}<br />Y = {Country=USA; TenantType=Edu; DataCenter=DC1}</p><p>如果 Y 的问题发生次数低于支持阈值，而 X 的发生次数高于支持阈值，那么 Y 及其所有子集都会被剪枝，而 X 则会保留。</p><h3 id="基于变化检测的剪枝">基于变化检测的剪枝</h3><p>除了影响程度之外，我们寻找的属性组合还应该与新出现的问题相关。换句话说，我们需要找出与问题报告数量（即突发次数）显著增加相对应的属性组合。</p><p>在获得基于影响程度进行剪枝的封闭项集后，我们考虑时间戳的信息并为每个封闭项集构建对应的时间序列数据，其中每个数据点都表示问题报告的数量。这时我们需要使用变化检测算法来检测时间序列中的变化点（即发生突发事件的点）。</p><p>iDice 采用 GLR（Generalized Likelihood Ratio）<sup id="a3"><a href="#f3">3</a></sup> 作为变化检测算法。变化检测可以表述为假设检验问题。假设时间序列的值拟合分布 <span class="math inline">\(\theta_0\)</span>，而变化区域内的值符合另一个分布 <span class="math inline">\(\theta_1\)</span>。即假设 <span class="math inline">\(H_0\)</span> 对应“无变化”，假设 <span class="math inline">\(H_1\)</span> 对应“变化”。</p><p>GLR 将保持一个阈值。给定几个连续的数据点，如果它们的对数似然比之和大于阈值，则将这些连续的数据点视为变化区域，而连续数据点的第一个点被视为变化点。例如下图，从 Dec-8 到 Dec-10 的点构成变化区域，并且 Dec-8 是改变点。而对于没有任何改变点的时间序列数据，将删除相应的属性组合。</p><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/20200405164216.png" style="zoom:50%;" /></p><center style="font-size:16px;color:#808080;text-decoration:underline">图3. 问题报告变化示例</center><p>假设我们有两组属性组合：</p><p>X = {Country=India; TenantType=Edu; DataCenter=DC6}<br />Y = {Country=UK; TenantType=Home; DataCenter=DC1}</p><p>它们对应的时间序列分别为 <span class="math inline">\(S_X\)</span> 和 <span class="math inline">\(S_Y\)</span>。如果我们发现 <span class="math inline">\(S_X\)</span> 的出现在 Dec-8（i.e. 变化点）有一个明显的变化（e.g., 从 100 上升到 300），而 <span class="math inline">\(S_Y\)</span> 并无明显的变化，则 Y 属性组合会被剪枝，而 <span class="math inline">\(S_X\)</span> 的变化点会被用在接下来的剪枝策略中。</p><h3 id="基于隔离能力的剪枝">基于隔离能力的剪枝</h3><p>有效组合应该能够将表现出变化的属性组合与其他没有变化的组合分开，为此提出了基于隔离能力的剪枝（Isolation Power based Pruning）。</p><p>隔离能力基于信息熵。另 <span class="math inline">\(S_X\)</span> 为属性组合 <span class="math inline">\(X\)</span> 对应的时间序列数据，<span class="math inline">\(X_a\)</span> 表示在 <span class="math inline">\(X\)</span> 的变化区域内，对应的时间序列 <span class="math inline">\(S_X\)</span> 的量的大小，而 <span class="math inline">\(X_b\)</span> 表示在 <span class="math inline">\(X\)</span> 的变化点之前对应的 <span class="math inline">\(S_X\)</span> 的量。<span class="math inline">\(\Omega_a\)</span> 表示 <span class="math inline">\(X\)</span> 变化区域内的整个体积，<span class="math inline">\(\Omega_b\)</span> 则表示 <span class="math inline">\(X\)</span> 的变化点之前的整个体积。<span class="math inline">\(\bar{*}\)</span> 表示相应时间序列的平均值。 <span class="math display">\[\begin{aligned}I P(X) &amp;=-\frac{1}{\overline{\Omega_{a}}+\overline{\Omega_{b}}}\left(\overline{X_{a}} \ln \frac{1}{P(a | X)}+\overline{X_{b}} \ln \frac{1}{P(b | X)}\right.\\&amp;\left.+(\overline{\Omega_{a}}-\overline{X_{a}}) \ln \frac{1}{P(a | \overline{X})}+(\overline{\Omega_{b}}-\overline{X_{b}}) \ln \frac{1}{P(b | \overline{X})}\right)\end{aligned}\]</span> 如图1所示，整个属性组合形成一个网格，网格中的每个节点都可以将数据集分为两部分：包含该属性的问题报告和不包含该属性的报告。如果属性组合是有效组合，则其所有子集节点在相同的变化区域内都应该显示出显著的增加，而其同级节点则不会。因此，一个有效的组合是可以将整个数据集精确地分为两部分的节点：是否有显著的增加。根据信息论，两个数据集（A 和 B）的总熵，在每个数据集（A 或 B）包含相同属性的样本（例如，所有样本都表现出增加，或者都表现出不增加）的情况下，会远小于样本具有不同属性的情况。 <span class="math display">\[\begin{aligned}&amp;P(a | X)=\frac{\overline{X_{a}}}{\overline{X_{b}}+\overline{\underline{X}_{a}}}, P(b | X)=\frac{\overline{X_{b}}}{\overline{X_{b}}+\overline{X_{a}}}\\&amp;P(a | \bar{X})=\frac{\overline{\Omega_{a}}-\overline{X_{a}}}{\overline{\Omega_{a}}+\overline{\Omega_{b}}-\overline{X_{b}}-\overline{X_{a}}}\\&amp;P(b | \bar{X})=\frac{\overline{\Omega_{b}}-\overline{X_{b}}}{\overline{\Omega_{a}}+\overline{\Omega_{b}}-\overline{X_{b}}-\overline{X_{a}}}\end{aligned}\]</span> 在搜索过程中，如果当前集合具有比它的直接超集和子集更高的隔离能力，则我们称当前集合是有效属性组合。在这种情况下，其所有子集将不会被搜索，从而减少搜索空间。</p><p>考虑具有三个属性组合的简单示例：</p><p>X = {Country=India; TenantType=Edu; DataCenter=DC6}<br />Y = {Country=USA; TenantType=Edu; DataCenter=DC1}</p><p>如果 Y 的发生率较低（即低于支持阈值），而 X 的发生率较高（高于支持阈值），则 Y 的所有子集将被修剪掉，而 X 将会保留。</p><h3 id="最终结果排名">最终结果排名</h3><p>根据上述剪枝的结果，我们可以获得一组有效的组合。我们根据有效组合的相对重要性对其进行排序。具体使用与 Fisher distance<sup id="a3"><a href="#f3">3</a></sup> 相似的算法进行排名。 <span class="math display">\[R = p_a \times ln \frac{p_a}{p_b}\]</span> 其中 p 由下面公式进行计算，<span class="math inline">\(V_{X_t}\)</span> 表示当前有效组合在时间段 t 的体积，<span class="math inline">\(V_t\)</span> 则表示在时间段 t 内的总体积。<span class="math inline">\(p_a\)</span> 表示在变化的时间段区间的比率，<span class="math inline">\(p_b\)</span> 则表示在检测到变化点之前的时间区间的比率。 <span class="math display">\[p = \frac{V_{X_t}}{V_t}\]</span> 从公式中可以看出，分数 R 考虑了组合的整体影响。如果两个组合具有相同的变化率（即意味着它们具有相同的趋势显著性），我们将把具有体积较大的组合排名更高。R 得分非常低的组合意义不大，可以删除。在具体的实现中，R 分数低于 cutoff 阈值将被剪掉（根据经验值设为 1.0）。最后对剩下的属性组合进行排名，并输出为有效组合。</p><h3 id="整体算法流程">整体算法流程</h3><p>算法 1 展示了上述识别有效组合的伪代码。该算法将问题报告数据（多维、时间序列数据）作为输入，并搜索与新出现的问题相关的有效组合。第 1 行的预处理包括数据清理，从而过滤出数据集中明显的噪声属性（例如所有的空值）。</p><p>对于基于 BFS 的封闭项目集挖掘过程返回的每个封闭项目集 <span class="math inline">\(p_i\)</span>，iDice 会依次执行基于影响程度的剪枝（第 6-10 行）、基于变化检测的剪枝（第 11-14 行）、基于隔离能力的剪枝（第 15-19 行）。这些步骤可以简化属性组合并减少搜索空间，从而有可能从大量属性组合中识别有效组合。第 21-26 行表示 iDice 的排名结果。</p><p><img src="https://cdn.jsdelivr.net/gh/davidlight2018/figure_bed/img/2020-04-08_15-27-36.png" style="zoom:40%;" /></p><h3 id="评测结果">评测结果</h3><p>评测结果就不在这里赘述了，毕竟每种数据集的各种参数都不相同，有兴趣的去看看原文。</p><h2 id="reference">Reference</h2><p><b id="f1">[1]: </b> Lin, Qingwei, et al. iDice: problem identification for emerging issues. <em>Proceedings of the 38th International Conference on Software Engineering</em>. 2016. <a href="#a1">↩︎</a></p><p><b id="f2">[2]: </b> J. Han and M. Kamber. Data Mining: Concepts and Techniques. Morgan kaufmann, 2006. <a href="#a2">↩︎</a></p><p><b id="f3">[3]: </b> M. Basseville, I. V. Nikiforov, et al. Detection of abrupt changes: theory and application, volume 104. Prentice Hall Englewood Cliﬀs, 1993. <a href="#a3">↩︎</a></p><hr />]]></content>
      
      
      
        <tags>
            
            <tag> AIOps </tag>
            
            <tag> 根因分析 </tag>
            
            <tag> 异常检测 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
